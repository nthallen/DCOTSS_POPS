%{
  #include "dasio/cmd_writer.h"
%}

# -----------------------------------------------------------------------------
# Partition 1: Main Line
# -----------------------------------------------------------------------------
State Init {
    > Telemetry Start
 +1 > MFC Bypass Flow Setpoint 0 nccm
    > MFC POPS Flow Setpoint 0 nccm
    > Set LFE PGain -4.0
    > Set LFE IGain -9.0
    > Set Bypass Pump PGain 0
    > Set Bypass Pump IGain 0
    depending on (OFF_GROUND) { Validate Startup; }
}

State Startup {
  depending on (ON_GROUND) { Validate Shutdown; }
  Validate POPS_Startup;
  Hold until valid (POPS_Is_Active);
  Validate POPS_Flow_PI_Init;
  Validate Bypass_Flow_Iso;
}

State Shutdown {
      Hold until valid (POPS_Is_Off, POPS_Flow_Off, Bypass_Flow_Off) or 2:00
      else {
        msg(2, "Timed out waiting for POPS, POPS_Flow and Bypass_Flow to shutdown");
      }
  +1  > Fail Light On
      > Quit
}

# -----------------------------------------------------------------------------
# Partition 2: Altitude
# -----------------------------------------------------------------------------
Partition

# This partition converts pressure (altitude) into states 
# (ON_GROUND, OFF_GROUND).
# The threshold pressures each have two values - one for 
# the flight up and the other for the flight down.
# This provides hysteresis and prevents bouncing.  
# Of course we need to ensure that P_ground_up < P_ground_dn,
# which is to say P_ground_up represent a higher altitude.
# We also want to ensure that P_ground_dn is high enough to
# allow the system to shutdown before landing while not being
# so high that it will be triggered during a mid-flight
# altitude scan. 

# MS5607_P is a float value in mbar
#
#
# REF: 650 torr ~867 mbar ~5000 ft
# Palmdale, CA is at elevation 2657'
# Salina, KS is at elevation 1227'

%{ /* Altitude definitions */
    double P_ground_up = 800.;
    double P_ground_dn = 850.;
    int using_swp = 0;
%}

State ON_GROUND {
  { using_swp = 0; }
  { if (using_swp || (MS5607_P > 0 && MS5607_P < P_ground_up))
      Validate OFF_GROUND;
  }
}

State OFF_GROUND {
  { if ((using_swp == SWS_LAND) || (!using_swp && MS5607_P > P_ground_dn)) {
      Validate ON_GROUND;
    }
  }
}

# -----------------------------------------------------------------------------
# Partition 3: POPS
# -----------------------------------------------------------------------------
Partition

State POPS_Idle {
  depending on (Shutdown) { Validate POPS_Shutdown; }
}

State POPS_Startup {
  depending on (Shutdown) { Validate POPS_Shutdown; }
  > POPS Power On
  Hold Until (POPS_Srvr == 1 || POPS_Srvr == 2) or 2:00
  else Validate POPS_Power_Cycle;
  Hold Until (POPS_Srvr == 2) or 1
  else > POPS Start
  Hold Until (POPS_Srvr == 2 && POPS_Stale == 0) or 10
  else Validate POPS_Comms;
  Validate POPS_Is_Active;
}

State POPS_Is_Active {
  depending on (Shutdown) { Validate POPS_Shutdown; }
}

State POPS_Power_Cycle {
      depending on (Shutdown) { Validate POPS_Shutdown; }
      > POPS Power Off
  +30 Validate POPS_Startup;
}

State POPS_Comms {
      depending on (Shutdown) { Validate POPS_Shutdown; }
      # POPS did not respond to Start command
      { msg(2, "POPS did not respond to Start command"); }
      > POPS Shutdown
      Hold Until (POPS_Srvr == 4) or 10;
  +30 Validate POPS_Power_Cycle;
}

State POPS_Shutdown {
  +1  { if (!POPSPwr) Validate POPS_Is_Off;
        else if (POPS_Stale > 3 && (POPS_srvr == 0 || POPS_srvr == 3))
          Validate POPS_Shutdown1;
      }
  +1  > POPS Shutdown
      Hold Until (POPS_srvr == 3 && POPS_Stale > 3) or 10;
  +30 Validate POPS_Shutdown1;
}

State POPS_Shutdown1 {
      > POPS Power Off
  +1  Validate POPS_Is_Off;
}

State POPS_Is_Off {}

# -----------------------------------------------------------------------------
# Partition 4: POPS Flow
# -----------------------------------------------------------------------------
Partition

%{
  double LFE_Set = 800.; // ccm
  double LFE_Gp = -4.0;  // Proportional Gain
  double LFE_Gi = -1.0;  // Integral Gain
  double LFE_I = 0.;     // Integral
  double LFE_err;
  double LFE_MFset;
  double T0 = 273.15;
  double P0 = 1013.25;   // 1 atm
%}

{ LFE_Gp = LFE_PGain; }
{ LFE_Gi = LFE_IGain; }

State POPS_Flow_Idle {
  depending on (Shutdown) { Validate POPS_Flow_Stop; }
}

State POPS_Flow_PI_Init {
  { LFE_I = 0.;
    Validate POPS_Flow_PI;
  }
}

State POPS_Flow_PI_Quick_Init {
  { LFE_I = LFE_Set/LFE_Gi;
    Validate POPS_Flow_PI;
  }
}

State POPS_Flow_PI {
  depending on (Shutdown) { Validate POPS_Flow_Stop; }
  {
    LFE_err = POPS_ccm - LFE_Set;
    LFE_I = LFE_I + LFE_err;
    LFE_MFset = (LFE_Gi*LFE_I + LFE_Gp*LFE_err)*
      (T0/(RingT+273.15))*(HPS_P/P0);
    if (LFE_MFset < 10) {
      if (PPmpS) {
        ci_sendfcmd(Cmd_Send, "Pump POPS Off\n");
      }
      if (LFE_MFset < 0) LFE_MFset = 0;
    }
    if (LFE_MFset > 1000) LFE_MFset = 1000; // Alicats limited to 2 SLM
    ci_sendfcmd(Cmd_Send_Quiet,
      "MFC POPS Flow SetPoint %.1lf nccm\n", LFE_MFset*1.75);
    /* ci_sendfcmd(Cmd_Send_Quiet,
      "MFC Sheath Flow SetPoint %.1lf nccm\n", LFE_MFset); */
    if (LFE_MFset > 10 && !PPmpS) {
      ci_sendfcmd(Cmd_Send, "Pump POPS On\n");
    }
  }
}

State POPS_Flow_Stop {
      > Pump POPS Off
  +1  > MFC POPS Flow SetPoint 0 nccm
#     > MFC Sheath Flow SetPoint 0 nccm
      Validate POPS_Flow_Off;
}

State POPS_Flow_Off {}

# -----------------------------------------------------------------------------
# Partition 5: Bypass Flow
# -----------------------------------------------------------------------------
Partition

%{
  double BP_Set = 800.; // ccm
  double BP_Gp = -4.0;  // Proportional Gain
  double BP_Gi = -1.0;  // Integral Gain
  double BP_I = 0.;     // Integral
  double BP_err;
  double BP_MFset;
  #define BP_update_period 1
  int BP_n_update;
%}

{ BP_Gp = BPmp_PGain; }
{ BP_Gi = BPmp_IGain; }

State Bypass_Flow_Idle {
  depending on (Shutdown) { Validate Bypass_Flow_Stop; }
  > MFC Bypass Flow SetPoint 5000 nccm
}

State Bypass_Flow_Iso_Init {
  { BP_I = 0;
    BP_n_update = BP_update_period-1;
    Validate Bypass_Flow_Iso;
  }
}

State Bypass_Flow_Iso {
      > MFC Bypass Flow SetPoint 5000 nccm
      Hold until (BMFC_Set > 4999) or 3
      else Validate Bypass_Flow_Iso;
   +1 > Pump Bypass On
  
  depending on (Shutdown) { Validate Bypass_Flow_Stop; }
  { double Fm_SPX, Fm_BMFC, Fm_err_BMFC, Vset;
    Fm_SPX = 120*(T0/(RingT+273.15))*(HPS_P/P0);
    Fm_BMFC = PD_nccm - PMFC_MassFlow - Fm_SPX;
    if (Fm_BMFC < 0) Fm_BMFC = 0;
    else if (Fm_BMFC > 5000) Fm_BMFC = 5000;
    
    /* BMFC_MF_LP is BMFC_MassFlow with a low pass filter */
    Fm_err_BMFC = BMFC_MF_LP - Fm_BMFC;
    BP_I = BP_I + Fm_err_BMFC;
    if (++BP_n_update >= BP_update_period) {
      Vset = (BP_Gp * Fm_err_BMFC - BP_Gi* BP_I)*
        (T0/(RingT+273.15))*(HPS_P/P0);

      if (Vset < 0) Vset = 0;
      else if (Vset > 5) Vset = 5;  
      ci_sendfcmd(Cmd_Send_Quiet,
        "Set Bypass Pump Speed %.2lf Volts\n", Vset);
      BP_n_update = 0;
    }
  }
}

State Bypass_Flow_Stop {
      > Pump Bypass Off
  +1  >MFC Bypass Flow SetPoint 0 nccm
      Validate Bypass_Flow_Off;
}

State Bypass_Flow_Off {}

# -----------------------------------------------------------------------------
# Partition 6: Old stuff
# -----------------------------------------------------------------------------

# State Pumps_Watch {
#   depending on (PPump_Failed) { Validate Pumps_Failed; }
#   depending on (BPump_Failed) { Validate Pumps_Failed; }
#   depending on (BPump_Idle, PPump_Idle) { Validate Pumps_Idle; }
#   +1:58 Validate Pumps_Step;
# }

# State Pumps_Step {
#   +1 Validate Pumps_Watch;
# }

# State Pumps_Failed {
#   Hold until (PMFC_MassFlow > 0.9 * PMFC_Set &&
#               BMFC_MassFlow > 0.9 * BMFC_Set);
#   +1 Validate Pumps_Watch;
# }

# # Pumps Partition
# # This should be totally passive except for Shutdown.
# # When the flow controller setpoints are set above 100 nccm,
# # The pumps will turn on. This partition will then cycle
# # between Pumps_Watch and Pumps_Step. If the flow through
# # either MFC drops below 1/2 the setpoint for 5 seconds,
# # it will advance to Pumps_Failed, shut off both pumps,
# # wait 20 minutes, and then restart. The point is to
# # guarantee 60 seconds of continuous flow at a particular
# # setpoint before advancing in the mainline algorithm.
# Partition

# State PPump_Off {
#   > Pump POPS Off
#   { if (PMFC_Set < 10)
#       Validate PPump_Idle; }
# }

# State PPump_Disable {
# }

# State PPump_Idle {
#   Hold until (PMFC_Set >= 10);
#   Validate PPump_On;
# }

# State PPump_On {
#   { if (PMFC_Set < 10)
#       Validate PPump_Off; }
#   +1  > Pump POPS On
#       Validate PPump_Watch;
# }

# State PPump_Watch {
#   { if (PMFC_Set < 10)
#       Validate PPump_Off; }
#   +1 Hold Until (PMFC_MassFlow < 0.5 * PMFC_Set);
#   +1 Hold Until (PMFC_MassFlow > 0.9 * PMFC_Set) or 5
#      else Validate PPump_Failed;
#      Validate PPump_Watch;
# }

# State PPump_Failed {
#   { if (PMFC_Set < 10)
#       Validate PPump_Off; }
#           > Pump POPS Off
#   +20:00  Validate PPump_On;
# }

# Partition

# State BPump_Off {
#   > Pump Bypass Off
#   { if (BMFC_Set < 10)
#       Validate BPump_Idle; }
# }

# State BPump_Disable {
# }

# State BPump_Idle {
#   Hold until (BMFC_Set >= 10);
#   Validate BPump_On;
# }

# State BPump_On {
#   { if (BMFC_Set < 10)
#       Validate BPump_Off; }
#   +1  > Pump Bypass On
#       Validate BPump_Watch;
# }

# State BPump_Watch {
#   { if (BMFC_Set < 10)
#       Validate BPump_Off; }
#   +1 Hold Until (BMFC_MassFlow < 0.5 * BMFC_Set);
#   +1 Hold Until (BMFC_MassFlow > 0.9 * BMFC_Set) or 5
#      else Validate BPump_Failed;
#      Validate BPump_Watch;
# }

# State BPump_Failed {
#   { if (BMFC_Set < 10)
#       Validate BPump_Off; }
#           > Pump Bypass Off
#   +20:00  Validate BPump_On;
# }
